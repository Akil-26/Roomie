rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Deny by default
    match /{document=**} {
      allow read, write: if false;
    }

    // User profiles
    // Readable by authenticated users (to show names/avatars), writable only by the owner
    match /users/{userId} {
      allow read: if request.auth != null; // profiles are visible to signed-in users
      
      // ðŸ”’ SECURITY: Only owner can write, and email must be unique or unchanged
      allow create: if request.auth != null && request.auth.uid == userId;
      
      allow update: if request.auth != null 
        && request.auth.uid == userId
        && (
          // Email unchanged OR new email is unique
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email'])
          || !exists(/databases/$(database)/documents/users/$(request.auth.uid))
        );
      
      // ðŸ”’ No client-side deletion
      allow delete: if false;

      // Subcollections: followers/following
      match /following/{targetUserId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      match /followers/{followerUserId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == followerUserId;
      }

      // Notifications scoped to a user
      match /notifications/{notificationId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      // SMS Transactions subcollection - owner only
      match /sms_transactions/{transactionId} {
        allow read, write: if request.auth != null && request.auth.uid == userId
          && isValidSmsTransaction();

        function isValidSmsTransaction() {
          return request.resource.data.keys().hasOnly([
              'id','userId','type','amount','timestamp','merchantName','bankName','upiId','mode','accountNumber',
              'referenceNumber','rawMessage','category','senderNumber'
            ])
            && request.resource.data.userId == request.auth.uid
            && request.resource.data.type in ['debit','credit']
            && request.resource.data.amount is number
            && request.resource.data.timestamp is timestamp;
        }
      }
    }

    // Groups collection
    // Browse groups when signed in; updates allowed to members of the group only
    match /groups/{groupId} {
      allow read: if request.auth != null;
      // Create allowed if creator is the current user and they are in the members list
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.members is list &&
        request.auth.uid in request.resource.data.members;

      // Update/Delete allowed only to members of the group
      allow update, delete: if request.auth != null &&
        resource.data.members is list &&
        request.auth.uid in resource.data.members;
    }

    // Join requests
    // Create: requester must be the authenticated user
    // Read: requester or any member of the target group
    // Update/Delete: requester can modify own request, or group members can change status
    match /joinRequests/{requestId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;

      function isGroupMember(groupId) {
        return request.auth != null &&
          (request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members);
      }

      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        (resource.data.groupId is string && isGroupMember(resource.data.groupId))
      );

      allow update, delete: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        (resource.data.groupId is string && isGroupMember(resource.data.groupId))
      );
    }

    // Per-user notifications top-level collection (if used):
    match /users/{userId}/notifications/{notificationId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ðŸ’¬ CHAT MESSAGES (Direct & Group)
    match /chats/{chatId}/messages/{messageId} {
      // Only participants can read messages
      allow read: if request.auth != null;
      
      // Only authenticated users can create messages
      allow create: if request.auth != null 
        && request.resource.data.senderId == request.auth.uid;
      
      // Only sender can update (for edit/delete)
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.senderId;
      
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.senderId;
    }

    // Group messages
    match /groups/{groupId}/messages/{messageId} {
      // Only group members can read
      allow read: if request.auth != null 
        && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
      
      // Only group members can create messages
      allow create: if request.auth != null 
        && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members
        && request.resource.data.senderId == request.auth.uid;
      
      // Only sender can update/delete
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.senderId;
      
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.senderId;
    }

    // ðŸ’¸ EXPENSES
    match /expenses/{expenseId} {
      // Group members can read group expenses
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.paidBy
        || request.auth.uid in resource.data.participants
      );
      
      // Anyone can create expense if they're the payer
      allow create: if request.auth != null 
        && request.resource.data.paidBy == request.auth.uid;
      
      // Only payer can update/delete
      allow update, delete: if request.auth != null 
        && request.auth.uid == resource.data.paidBy;
    }
  }
}